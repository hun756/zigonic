pub const predicates = @import("predicates/mod.zig");
pub const searching = @import("searching/mod.zig");
pub const transforming = @import("transforming/mod.zig");
pub const comparison = @import("comparison/mod.zig");
pub const encoding = @import("encoding/mod.zig");
pub const sorting = @import("sorting/mod.zig");
pub const numeric = @import("numeric/mod.zig");
pub const modifying = @import("modifying/mod.zig");
pub const nonmodifying = @import("nonmodifying/mod.zig");
pub const setops = @import("setops/mod.zig");
pub const heap = @import("heap/mod.zig");
pub const permutation = @import("permutation/mod.zig");
pub const partitioning = @import("partitioning/mod.zig");
pub const parallel = @import("parallel/mod.zig");
pub const strings = @import("strings/mod.zig");
pub const bitwise = @import("bitwise/mod.zig");
pub const functional = @import("functional/mod.zig");
pub const hashing = @import("hashing/mod.zig");
pub const math = @import("math/mod.zig");
pub const graph = @import("graph/mod.zig");
pub const datastructs = @import("datastructs/mod.zig");
pub const compression = @import("compression/mod.zig");
pub const memory = @import("memory/mod.zig");
pub const intervals = @import("intervals/mod.zig");
pub const simd = @import("simd/mod.zig");

pub const allOf = predicates.allOf;
pub const allOfComptime = predicates.allOfComptime;
pub const anyOf = predicates.anyOf;
pub const anyOfComptime = predicates.anyOfComptime;
pub const noneOf = predicates.noneOf;
pub const countIf = predicates.countIf;
pub const count = predicates.count;

pub const binarySearch = searching.binarySearch;
pub const binarySearchBy = searching.binarySearchBy;
pub const lowerBound = searching.lowerBound;
pub const upperBound = searching.upperBound;
pub const equalRange = searching.equalRange;
pub const contains = searching.contains;
pub const linearSearch = searching.linearSearch;
pub const find = searching.find;
pub const findIf = searching.findIf;

pub const accumulate = transforming.accumulate;
pub const sum = transforming.sum;
pub const sumChecked = transforming.sumChecked;
pub const product = transforming.product;
pub const reduce = transforming.reduce;
pub const bifurcate = transforming.bifurcate;
pub const partition = transforming.partition;
pub const map = transforming.map;
pub const filter = transforming.filter;
pub const filterMap = transforming.filterMap;

pub const maxElement = comparison.maxElement;
pub const maxElementBy = comparison.maxElementBy;
pub const minElement = comparison.minElement;
pub const minElementBy = comparison.minElementBy;
pub const minMax = comparison.minMax;
pub const clamp = comparison.clamp;
pub const min = comparison.min;
pub const max = comparison.max;
pub const minBy = comparison.minBy;
pub const maxBy = comparison.maxBy;

pub const base64 = encoding.base64;
pub const hex = encoding.hex;

pub const insertionSort = sorting.insertionSort;
pub const insertionSortBy = sorting.insertionSortBy;
pub const quickSort = sorting.quickSort;
pub const quickSortBy = sorting.quickSortBy;
pub const heapSort = sorting.heapSort;
pub const heapSortBy = sorting.heapSortBy;
pub const partialSort = sorting.partialSort;
pub const partialSortBy = sorting.partialSortBy;
pub const partialSortCopy = sorting.partialSortCopy;
pub const partialSortCopyBy = sorting.partialSortCopyBy;
pub const nthElement = sorting.nthElement;
pub const nthElementBy = sorting.nthElementBy;
pub const isSorted = sorting.isSorted;
pub const isSortedBy = sorting.isSortedBy;
pub const isSortedUntil = sorting.isSortedUntil;
pub const isSortedUntilBy = sorting.isSortedUntilBy;
pub const stableSort = sorting.stableSort;
pub const stableSortBy = sorting.stableSortBy;
pub const sort = sorting.introSort;
pub const sortBy = sorting.introSortBy;

pub const iota = numeric.iota;
pub const partialSum = numeric.partialSum;
pub const adjacentDifference = numeric.adjacentDifference;
pub const innerProduct = numeric.innerProduct;
pub const gcd = numeric.gcd;
pub const lcm = numeric.lcm;
pub const numericReduce = numeric.reduce;
pub const exclusiveScan = numeric.exclusiveScan;
pub const inclusiveScan = numeric.inclusiveScan;
pub const transformReduce = numeric.transformReduce;
pub const transformExclusiveScan = numeric.transformExclusiveScan;
pub const transformInclusiveScan = numeric.transformInclusiveScan;
pub const midpoint = numeric.midpoint;

pub const copy = modifying.copy;
pub const copyIf = modifying.copyIf;
pub const copyN = modifying.copyN;
pub const copyBackward = modifying.copyBackward;
pub const fill = modifying.fill;
pub const fillN = modifying.fillN;
pub const generate = modifying.generate;
pub const generateN = modifying.generateN;
pub const transform = modifying.transform;
pub const transformBinary = modifying.transformBinary;
pub const replace = modifying.replace;
pub const replaceIf = modifying.replaceIf;
pub const replaceCopy = modifying.replaceCopy;
pub const replaceCopyIf = modifying.replaceCopyIf;
pub const reverse = modifying.reverse;
pub const reverseCopy = modifying.reverseCopy;
pub const rotate = modifying.rotate;
pub const rotateCopy = modifying.rotateCopy;
pub const shuffle = modifying.shuffle;
pub const unique = modifying.unique;
pub const uniqueCopy = modifying.uniqueCopy;
pub const remove = modifying.remove;
pub const removeIf = modifying.removeIf;
pub const removeCopy = modifying.removeCopy;
pub const removeCopyIf = modifying.removeCopyIf;
pub const swapRanges = modifying.swapRanges;
pub const shiftLeft = modifying.shiftLeft;
pub const shiftRight = modifying.shiftRight;
pub const sample = modifying.sample;

pub const findIfNot = nonmodifying.findIfNot;
pub const findFirstOf = nonmodifying.findFirstOf;
pub const adjacentFind = nonmodifying.adjacentFind;
pub const adjacentFindBy = nonmodifying.adjacentFindBy;
pub const mismatch = nonmodifying.mismatch;
pub const mismatchBy = nonmodifying.mismatchBy;
pub const equal = nonmodifying.equal;
pub const equalBy = nonmodifying.equalBy;
pub const search = nonmodifying.search;
pub const searchN = nonmodifying.searchN;
pub const findEnd = nonmodifying.findEnd;
pub const lexicographicalCompare = nonmodifying.lexicographicalCompare;
pub const forEach = nonmodifying.forEach;
pub const forEachN = nonmodifying.forEachN;

pub const merge = setops.merge;
pub const mergeBy = setops.mergeBy;
pub const inplaceMerge = setops.inplaceMerge;
pub const inplaceMergeBy = setops.inplaceMergeBy;
pub const setUnion = setops.setUnion;
pub const setUnionBy = setops.setUnionBy;
pub const setIntersection = setops.setIntersection;
pub const setIntersectionBy = setops.setIntersectionBy;
pub const setDifference = setops.setDifference;
pub const setDifferenceBy = setops.setDifferenceBy;
pub const setSymmetricDifference = setops.setSymmetricDifference;
pub const setSymmetricDifferenceBy = setops.setSymmetricDifferenceBy;
pub const includes = setops.includes;
pub const includesBy = setops.includesBy;

pub const makeHeap = heap.makeHeap;
pub const makeHeapBy = heap.makeHeapBy;
pub const pushHeap = heap.pushHeap;
pub const pushHeapBy = heap.pushHeapBy;
pub const popHeap = heap.popHeap;
pub const popHeapBy = heap.popHeapBy;
pub const sortHeap = heap.sortHeap;
pub const sortHeapBy = heap.sortHeapBy;
pub const isHeap = heap.isHeap;
pub const isHeapBy = heap.isHeapBy;
pub const isHeapUntil = heap.isHeapUntil;
pub const isHeapUntilBy = heap.isHeapUntilBy;

pub const nextPermutation = permutation.nextPermutation;
pub const nextPermutationBy = permutation.nextPermutationBy;
pub const prevPermutation = permutation.prevPermutation;
pub const prevPermutationBy = permutation.prevPermutationBy;
pub const isPermutation = permutation.isPermutation;
pub const isPermutationBy = permutation.isPermutationBy;

pub const isPartitioned = partitioning.isPartitioned;
pub const partitionAlgo = partitioning.partition;
pub const partitionCopy = partitioning.partitionCopy;
pub const stablePartition = partitioning.stablePartition;
pub const partitionPoint = partitioning.partitionPoint;

pub const ParallelConfig = parallel.ParallelConfig;
pub const parallelFor = parallel.parallelFor;
pub const parallelForEach = parallel.parallelForEach;
pub const parallelReduce = parallel.parallelReduce;
pub const parallelTransform = parallel.parallelTransform;
pub const parallelSort = parallel.parallelSort;
pub const parallelSortDefault = parallel.parallelSortDefault;
pub const parallelFind = parallel.parallelFind;
pub const parallelCount = parallel.parallelCount;
pub const parallelCountIf = parallel.parallelCountIf;
pub const parallelAllOf = parallel.parallelAllOf;
pub const parallelAnyOf = parallel.parallelAnyOf;
pub const parallelNoneOf = parallel.parallelNoneOf;
pub const parallelFill = parallel.parallelFill;
pub const parallelCopy = parallel.parallelCopy;
pub const parallelMinElement = parallel.parallelMinElement;
pub const parallelMaxElement = parallel.parallelMaxElement;
pub const parallelReplace = parallel.parallelReplace;
pub const parallelReplaceIf = parallel.parallelReplaceIf;
pub const parallelEqual = parallel.parallelEqual;
pub const parallelIota = parallel.parallelIota;
pub const parallelAdjacentDifference = parallel.parallelAdjacentDifference;
pub const parallelInnerProduct = parallel.parallelInnerProduct;

pub const kmpSearch = strings.kmpSearch;
pub const boyerMooreSearch = strings.boyerMooreSearch;
pub const rabinKarpSearch = strings.rabinKarpSearch;
pub const levenshteinDistance = strings.levenshteinDistance;
pub const longestCommonSubstring = strings.longestCommonSubstring;
pub const longestCommonSubsequence = strings.longestCommonSubsequence;
pub const isPalindrome = strings.isPalindrome;
pub const reverseString = strings.reverseString;
pub const countSubstrings = strings.countSubstrings;
pub const hammingDistance = strings.hammingDistance;
pub const trim = strings.trim;
pub const trimLeft = strings.trimLeft;
pub const trimRight = strings.trimRight;
pub const split = strings.split;
pub const strJoin = strings.join;
pub const startsWith = strings.startsWith;
pub const endsWith = strings.endsWith;
pub const strContains = strings.strContains;
pub const strReplace = strings.strReplace;

pub const popcount = bitwise.popcount;
pub const countTrailingZeros = bitwise.countTrailingZeros;
pub const countLeadingZeros = bitwise.countLeadingZeros;
pub const isPowerOfTwo = bitwise.isPowerOfTwo;
pub const nextPowerOfTwo = bitwise.nextPowerOfTwo;
pub const reverseBits = bitwise.reverseBits;
pub const rotateLeft = bitwise.rotateLeft;
pub const rotateRight = bitwise.rotateRight;
pub const getBit = bitwise.getBit;
pub const setBit = bitwise.setBit;
pub const clearBit = bitwise.clearBit;
pub const toggleBit = bitwise.toggleBit;
pub const extractBits = bitwise.extractBits;
pub const setBits = bitwise.setBits;
pub const parity = bitwise.parity;
pub const swapBits = bitwise.swapBits;
pub const grayCode = bitwise.grayCode;
pub const inverseGrayCode = bitwise.inverseGrayCode;
pub const hammingWeight = bitwise.hammingWeight;
pub const hammingDistanceBits = bitwise.hammingDistanceBits;
pub const findFirstSet = bitwise.findFirstSet;
pub const findLastSet = bitwise.findLastSet;
pub const isolateRightmostBit = bitwise.isolateRightmostBit;
pub const clearRightmostBit = bitwise.clearRightmostBit;
pub const byteSwap = bitwise.byteSwap;
pub const bitReverse8 = bitwise.bitReverse8;
pub const bitReverse16 = bitwise.bitReverse16;
pub const bitReverse32 = bitwise.bitReverse32;
pub const bitsRequired = bitwise.bitsRequired;

pub const compose = functional.compose;
pub const pipe = functional.pipe;
pub const fnNegate = functional.negate;
pub const conjunct = functional.conjunct;
pub const disjunct = functional.disjunct;
pub const applyN = functional.applyN;
pub const fnIterate = functional.iterate;
pub const unfold = functional.unfold;
pub const zipWith = functional.zipWith;
pub const scanLeft = functional.scanLeft;
pub const scanRight = functional.scanRight;
pub const takeWhile = functional.takeWhile;
pub const dropWhile = functional.dropWhile;
pub const fnSpan = functional.span;
pub const groupBy = functional.groupBy;
pub const intersperse = functional.intersperse;
pub const intercalate = functional.intercalate;
pub const chunks = functional.chunks;
pub const fnWindows = functional.windows;
pub const fnFlatten = functional.flatten;
pub const transpose = functional.transpose;

pub const fnv1a32 = hashing.fnv1a32;
pub const fnv1a64 = hashing.fnv1a64;
pub const djb2 = hashing.djb2;
pub const sdbm = hashing.sdbm;
pub const jenkinsOneAtATime = hashing.jenkinsOneAtATime;
pub const murmur3_32 = hashing.murmur3_32;
pub const xxHash32 = hashing.xxHash32;
pub const adler32 = hashing.adler32;
pub const crc32 = hashing.crc32;
pub const crc16 = hashing.crc16;
pub const pearsonHash = hashing.pearsonHash;
pub const fletcher16 = hashing.fletcher16;
pub const fletcher32 = hashing.fletcher32;
pub const checksum8Xor = hashing.checksum8Xor;
pub const checksum8Sum = hashing.checksum8Sum;
pub const checksum16 = hashing.checksum16;
pub const hashCombine = hashing.hashCombine;

// Math / Number Theory exports
pub const mathGcd = math.gcd;
pub const binaryGcd = math.binaryGcd;
pub const mathLcm = math.lcm;
pub const extendedGcd = math.extendedGcd;
pub const isPrime = math.isPrime;
pub const sievePrimes = math.sievePrimes;
pub const segmentedSieve = math.segmentedSieve;
pub const primeFactors = math.primeFactors;
pub const modPow = math.modPow;
pub const modMul = math.modMul;
pub const modInverse = math.modInverse;
pub const chineseRemainder = math.chineseRemainder;
pub const eulerTotient = math.eulerTotient;
pub const mobiusFunction = math.mobiusFunction;
pub const isqrt = math.isqrt;
pub const intNthRoot = math.intNthRoot;
pub const isPerfectSquare = math.isPerfectSquare;
pub const isPerfectPower = math.isPerfectPower;
pub const fibonacci = math.fibonacci;
pub const binomial = math.binomial;
pub const catalan = math.catalan;

// Graph algorithm exports
pub const AdjacencyList = graph.AdjacencyList;
pub const bfs = graph.bfs;
pub const dfs = graph.dfs;
pub const dijkstra = graph.dijkstra;
pub const bellmanFord = graph.bellmanFord;
pub const topologicalSort = graph.topologicalSort;
pub const hasCycle = graph.hasCycle;
pub const stronglyConnectedComponents = graph.stronglyConnectedComponents;
pub const primMST = graph.primMST;

// Data structures exports
pub const UnionFind = datastructs.UnionFind;
pub const BloomFilter = datastructs.BloomFilter;
pub const LRUCache = datastructs.LRUCache;
pub const SkipList = datastructs.SkipList;
pub const Trie = datastructs.Trie;

// Compression exports
pub const rleEncode = compression.rleEncode;
pub const rleDecode = compression.rleDecode;
pub const deltaEncode = compression.deltaEncode;
pub const deltaDecode = compression.deltaDecode;
pub const vlqEncode = compression.vlqEncode;
pub const vlqDecode = compression.vlqDecode;
pub const LZ77Token = compression.LZ77Token;
pub const lz77Compress = compression.lz77Compress;
pub const lz77Decompress = compression.lz77Decompress;
pub const bwtTransform = compression.bwtTransform;
pub const bwtInverse = compression.bwtInverse;
pub const mtfEncode = compression.mtfEncode;
pub const mtfDecode = compression.mtfDecode;

// Memory utilities exports
pub const RingBuffer = memory.RingBuffer;
pub const ObjectPool = memory.ObjectPool;
pub const ScopedArena = memory.ScopedArena;
pub const SlabAllocator = memory.SlabAllocator;
pub const BumpAllocator = memory.BumpAllocator;
pub const Deque = memory.Deque;

// Interval exports
pub const Interval = intervals.Interval;
pub const IntervalTree = intervals.IntervalTree;
pub const mergeIntervals = intervals.mergeIntervals;
pub const findOverlapping = intervals.findOverlapping;
pub const maxNonOverlapping = intervals.maxNonOverlapping;
pub const minMeetingRooms = intervals.minMeetingRooms;
pub const insertInterval = intervals.insertInterval;
pub const totalCoverage = intervals.totalCoverage;

// SIMD exports
pub const simdFill = simd.simdFill;
pub const simdSum = simd.simdSum;
pub const simdDotProduct = simd.simdDotProduct;
pub const simdMin = simd.simdMin;
pub const simdMax = simd.simdMax;
pub const simdEqual = simd.simdEqual;
pub const simdContains = simd.simdContains;
pub const simdAdd = simd.simdAdd;
pub const simdMul = simd.simdMul;
pub const blockTranspose = simd.blockTranspose;

test {
    @import("std").testing.refAllDecls(@This());
}
